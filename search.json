[{"title":"单链表基本操作实现","url":"/2021/09/19/SingleLinkedList/","content":"链表链表的基本概念链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的，链表每个节点有两部分分组成，一个是数据域（也就是该元素的数据信息）用element表示，一个是指针域（与就是对于下一个节点的引用）用next表示；\n链表的设计与实现\n接口设计/** * 清除所有元素 */void clear();/** * 元素的数量 * @return */int size();/** * 是否为空 * @return */boolean isEmpty();/** * 是否包含某个元素 * @param element * @return */boolean contains(E element);/** * 添加元素到尾部 * @param element */void add(E element);/** * 获取index位置的元素 * @param index * @return */E get(int index);/** * 设置index位置的元素 * @param index * @param element * @return 原来的元素ֵ */E set(int index, E element);/** * 在index位置插入一个元素 * @param index * @param element */void add(int index, E element);/** * 删除index位置的元素 * @param index * @return */E remove(int index);/** * 查看元素的索引 * @param element * @return */int indexOf(E element);\n\n接口的实现package priv.kun.LinkedList;/** * @author likun * @Package priv.kun.LinkedList * @Description: * @date */public class SingleLinkedList&lt;E&gt; &#123;    private int size; //元素的数量    private Node&lt;E&gt; first; //头节点    private static class Node&lt;E&gt;&#123;        E element;        Node&lt;E&gt; next;        public Node(E element,Node&lt;E&gt; next)&#123;            this.element=element;            this.next=next;        &#125;    &#125;    /**     * 清空     * size设置为0 ，头节点为null     */    public void clear() &#123;        size=0;        first=null;    &#125;    /**     * 元素的数量     * @return     */    public int size() &#123;        return size;    &#125;    /**     * 是否为空     * @return     */    public boolean isEmpty() &#123;        return size==0;    &#125;    /**     * 返回某个元素的位置     * @param element     * @return     */    public int indexOf(E element) &#123;        if (element==null)&#123;            Node&lt;E&gt; node=first;            for (int i=0;i&lt;size;i++)&#123;                if (node.element==null) return i;                node=node.next;            &#125;        &#125;else &#123;            Node&lt;E&gt; node=first;            for (int i=0;i&lt;size;i++)&#123;                if (element.equals(node.element)) return i;                node=node.next;            &#125;        &#125;        return -1;    &#125;    /**     * 是否包含某个元素     * @param element     * @return     */    public boolean contains(E element) &#123;        return indexOf(element) != -1;    &#125;    /**     * 在尾部添加元素     * @param element     */    public void add(E element) &#123;        add(size,element);    &#125;    /**     * 在index位置添加元素     * @param index     * @param element     */    public void add(int index, E element) &#123;        if (index == 0) &#123;            first = new Node&lt;&gt;(element, null);        &#125; else &#123;            Node&lt;E&gt; prev = node(index - 1);            prev.next = new Node&lt;&gt;(element, prev.next);        &#125;        size++;    &#125;    /**     * 返回 index位置的元素     * @param index     * @return     */    public E get(int index) &#123;        return node(index).element;    &#125;    /**     * 返回某个位置节点     * @param index     * @return     */    public Node&lt;E&gt; node(int index)&#123;        Node&lt;E&gt; node=first;        for (int i=0;i&lt;index;i++)&#123;            node=node.next;        &#125;        return node;    &#125;    /**     * 设置index位置的元素     * @param index     * @param element     * @return     */    public E set(int index, E element) &#123;        Node&lt;E&gt; node = node(index); //找到index 位置的节点        E oldElement = node.element;        node.element=element;        return oldElement;    &#125;    /**     * 删除 index位置的元素     * @param index     * @return     */    public E remove(int index) &#123;        Node&lt;E&gt; node = node(index);//删除的节点        if (index==0)&#123; //删除的是第一个节点            first=node.next;        &#125; else &#123;            Node&lt;E&gt; prev = node(index - 1); //删除的前一个节点            Node&lt;E&gt; next = node.next; //删除节点的后一个节点            prev.next=next; //        &#125;        size--;        return node.element;    &#125;    @Override    public String toString() &#123;        StringBuilder stringBuilder = new StringBuilder();        stringBuilder.append(&quot;size:&quot;).append(size).append(&quot; ,[&quot;);        Node&lt;E&gt; node=first;        for (int i=0;i&lt;size;i++)&#123;            if (i!=0)&#123;                stringBuilder.append(&quot;,&quot;);            &#125;            stringBuilder.append(node.element);            node=node.next;        &#125;        stringBuilder.append(&quot;]&quot;);        return stringBuilder.toString();    &#125;&#125;\n\n测试@Test   public void test1()&#123;       SingleLinkedList&lt;Integer&gt; list = new SingleLinkedList&lt;&gt;();       list.add(1);       list.add(2);       list.set(0,111);       System.out.println(list.get(0));       System.out.println(list);   &#125;\n\n这里的实现并没有做一些非法参数传入入的处理，例如node(-5),这一看就不合理，默认先认为传入的数据都是合理的，并且有一些错误java就可以抛出异常。\n（实现的可能有错误，或者不合理的地方，等发现在修改）\nC语言实现链表实现思路和上面一样，\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /*     定义结构 */typedef struct Node&#123;    int  element;   //c语言中好像没有泛型，默认就是int类型的元素      struct Node *next;&#125;Node;Node* init();Node* add(Node* frist,int element); //添加节点Node* addForIndex(Node* first,int index,int element); //添加节点在index位置Node* findNode(Node* frist,int index);  //查找index位置的节点void display(Node *p);  //打印Node* del(Node *first,int index);  //删除index位置的节点Node* clear(Node* first); //清空//Node *first; //定义单链表的头指针int size=0; //元素数量Node* init()&#123;    Node * first;    first=NULL;    return first;&#125;/* 添加节点 */Node* add(Node* first,int element)&#123;    return addForIndex(first,size,element);&#125;/* 在index位置添加节点 */Node* addForIndex(Node* first,int index,int element)&#123;    if(size==0)&#123;        Node *c=(Node*)malloc(sizeof(Node));  //分配一个节点，并让指针p指向这个节点        first=c;      /*   first-&gt;element=element;        first-&gt;next=NULL; */        first-&gt; element=element;        first-&gt; next=NULL;     &#125;else&#123;        Node *c=(Node*)malloc(sizeof(Node));  //添加的节点        Node *prev=findNode(first,index-1);  //添加节点的前一个节点        c-&gt; element=element;        c-&gt; next=prev-&gt;next;        prev-&gt;next=c;    &#125;    size++;    return first;&#125;Node* findNode(Node* first,int index)&#123;    Node *temp=first;    for(int i=0;i&lt;index;i++)&#123;        temp=temp-&gt;next;    &#125; /*     Node *c=(Node*)malloc(sizeof(Node)); */    return temp;&#125;void display(Node *p)&#123;    Node* temp=p;    while (temp!=NULL) &#123;        printf(&quot;%d &quot;,temp-&gt;element);        temp=temp-&gt;next;    &#125;    printf(&quot;\\n&quot;);    printf(&quot;size=%d&quot;,size);    printf(&quot;\\n&quot;);&#125;/** * 删除节点 */Node* del(Node* first,int index)&#123;    Node *del=findNode(first,index); //删除的节点    if(index==0)&#123;        first=del-&gt;next;    &#125;else&#123;        Node *prev=findNode(first,index-1);        prev-&gt;next=prev-&gt;next-&gt;next;    &#125;    free(del);    size--;    return first;&#125;Node* clear(Node* first)&#123;    int temp=size;    for(int i=0;i&lt;temp;i++)&#123;        del(first,0);    &#125;    size=0;    return first;&#125;void main()&#123;    // add(2);    // add(3);    // add(4);    // addForIndex(3,6);    // //clear();    // add(5644);    // /* del(0);    // del(3); */    // del(0);    // del(0);    // del(0);    // clear();    // add(123);    // display(first);   /*  Node *c=findNode(2);    printf(&quot;%d&quot;,c-&gt;element); */     Node* first=init();   first=add(first,1);   first=add(first,3);   first=del(first,0);   clear(first);   first=add(first,123);    display(first);     printf(&quot;\\nthis is main&quot;);&#125;\n\n","categories":["数据结构"],"tags":["链表"]},{"title":"二叉搜索树基本操作实现","url":"/2021/09/24/BinarySearchTree/","content":"二叉搜索树package priv.kun._07_binarySearchTree;import priv.kun._07_binarySearchTree.printer.BinaryTreeInfo;import java.util.Comparator;import java.util.LinkedList;import java.util.Queue;/** * @author likun * @Package priv.kun._07_binarySearchTree * @Description: * @date  */public class BinarySearchTree&lt;E&gt; implements BinaryTreeInfo &#123;    private int size;    private Node&lt;E&gt; root; //根节点    private Comparator&lt;E&gt; comparator; //比较器， 从外部传入    public BinarySearchTree()&#123;        this(null);    &#125;    public BinarySearchTree(Comparator&lt;E&gt; comparator)&#123;        this.comparator=comparator;    &#125;    private static class Node&lt;E&gt;&#123;        E element;        Node&lt;E&gt; left;        Node&lt;E&gt; right;        Node&lt;E&gt; parent;        public Node(E element,Node parent)&#123;            this.element=element;            this.parent=parent;        &#125;        /**         *         * @return         */        public boolean ifLeft()&#123;            return left == null &amp;&amp; right == null;        &#125;        public boolean haveTwoChildren()&#123;            return left!=null&amp;&amp;right!=null;        &#125;    &#125;    public int size()&#123;        return 0;    &#125;    public boolean isEmpty()&#123;        return size==0;    &#125;    public void clear()&#123;        root=null;        size=0;    &#125;    public static abstract class Visitor&lt;E&gt;&#123;        boolean stop;        public abstract Boolean visit(E element);    &#125;    /**     * 前序遍历     *  递归实现     */    public void preorderTraversal(Visitor&lt;E&gt; visitor)&#123;        preorderTraversal(root,visitor);    &#125;    private void preorderTraversal(Node&lt;E&gt; node,Visitor&lt;E&gt; visitor)&#123;        if (node==null||visitor.stop) return;        visitor.stop=visitor.visit(node.element);        preorderTraversal(node.left,visitor);        preorderTraversal(node.right,visitor);    &#125;    /**     * 中序遍历     */    public void inorderTraversal(Visitor&lt;E&gt; visitor)&#123;        if (visitor==null) return;        inorderTraversal(root,visitor);    &#125;    private void inorderTraversal(Node&lt;E&gt; node,Visitor&lt;E&gt; visitor)&#123;        if (node==null||visitor.stop) return;        inorderTraversal(node.left,visitor);        if (visitor.stop) return;        visitor.stop = visitor.visit(node.element);        inorderTraversal(node.right,visitor);    &#125;    /**     * 后序遍历     */    public void postorderTraversal(Visitor&lt;E&gt; visitor)&#123;        if (visitor==null) return;        postorderTraversal(root,visitor);    &#125;    private void postorderTraversal(Node&lt;E&gt; node,Visitor visitor)&#123;        if (node==null||visitor.stop) return;        postorderTraversal(node.left,visitor);        postorderTraversal(node.right,visitor);        if (visitor.stop) return;        visitor.stop= visitor.visit(node.element);    &#125;    /**     * 层序遍历     */    public void levelOrderTraversal(Visitor&lt;E&gt; visitor)&#123;        if (root==null) return;        Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root); //入队        while (!queue.isEmpty())&#123;            Node&lt;E&gt; node = queue.poll();//出队            Boolean aBoolean = visitor.visit(node.element);            if (aBoolean) return;            if (node.left!=null)&#123;                queue.offer(node.left);            &#125;            if (node.right!=null)&#123;                queue.offer(node.right);            &#125;        &#125;    &#125;    /**     * 添加节点     * @param element     */    public void add(E element)&#123;        elementNotNullCheck(element);        if (root==null)&#123; //添加根节点            root=new Node&lt;E&gt;(element,null);            size++;            return;        &#125;        //添加执行到这里没有返回的话，添加的就不是根节点        Node&lt;E&gt; parent=root;        Node&lt;E&gt; node=root;        int compare=0;        while (node!=null)&#123;             compare = compare(element, node.element);            parent=node;            if (compare&gt;0)&#123;                node=node.right;            &#125;else if(compare&lt;0)&#123;                node=node.left;            &#125;else &#123;                //等于0                node.element = element;                return;            &#125;        &#125;        //创建一个新的节点插入        Node&lt;E&gt; newNode = new Node&lt;&gt;(element, parent); //这个是新插入的节点        if(compare&gt;0)&#123;            // 插到父节点的右边            parent.right=newNode;        &#125;else &#123;            parent.left=newNode;        &#125;    &#125;    /**     *     * @param e1     * @param e2     * @return 返回值等于0 e1,e2相等     *          返回值大于0 e1大于e2     *          返回值小于0 e1小于e2     */    private int compare(E e1, E e2) &#123;        if (comparator!=null)&#123; //比较器不等null,也就是外部传入了一个比较规则            //用外部传入的规则比较            int compare = comparator.compare(e1, e2);            return compare;        &#125;        //没有穿比较器        //但是一定要有比较规则，将他强制转换，使用他默认的比较规则        int i = ((Comparable&lt;E&gt;) e1).compareTo(e2);        return i;    &#125;    /**     * 检查添加的节点是为空     * 如果元素为空，抛出异常 -》参数异常     * @param element     */    private void elementNotNullCheck(E element) &#123;        if (element==null)&#123;            throw new IllegalArgumentException(&quot;element不能为空&quot;);  //非法参数异常        &#125;    &#125;    /**     * 树的高度 递归     *  （树的高度，就是根节点的高度）     * @return     */    public int height()&#123;        return height(root);    &#125;    private int height(Node&lt;E&gt; node)&#123;        if(node==null) return 0;        int max = Math.max(height(node.left), height(node.left));        return max+1;    &#125;    /**     * 树的高度，递归     * @return     */    public int height2()&#123;        if (root==null) return 0;        int height=0; //树高        int levelSize=1; // 每一层元素的数量        Queue&lt;Node&lt;E&gt;&gt; queue=new LinkedList&lt;&gt;();        queue.offer(root); //入队        while (!queue.isEmpty())&#123;            Node&lt;E&gt; node = queue.poll();            levelSize--;            if (node.left!=null)&#123;                queue.offer(node.left);            &#125;            if (node.right!=null)&#123;                queue.offer(node.right);            &#125;            if (levelSize==0)&#123;                levelSize=queue.size();                height++;            &#125;        &#125;        return height;    &#125;    /**     * 判断是否为完全二叉树     *     *  node.left!=null&amp;&amp;node.right!=null  不是叶子节点，继续进栈出栈操作     *  node.left==null&amp;&amp; node.right!=null 不是二叉树 返回false     *  node.left==null &amp;&amp; node.right==null  和     *  node.left==null &amp;&amp; node.right==null  这两个即为叶子节点，之后在遍历到的节点均不能再有子节点，则是完全二叉树，否则为false     *     *     * @return true：完全二叉树        false:不是完全二叉树     */    public boolean isComplete()&#123;        if (root==null) return false;        Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root); //        boolean left=false; //        while (!queue.isEmpty())&#123;            Node&lt;E&gt; node = queue.poll();            if (left &amp;&amp; !node.ifLeft()) return false;            if (node.haveTwoChildren())&#123;                queue.offer(node.left);                queue.offer(node.right);            &#125;else if (node.left==null &amp;&amp;node.left!=null)&#123;                return false;            &#125;else &#123;                //侯面的节点都是叶子节点                left=true;                if (node.left!=null)&#123;                        queue.offer(node.left);                &#125;            &#125;        &#125;        return  true;    &#125;    /**     * 判断是否为完全二叉树     * @return     */    public boolean isComplete2()&#123;        if (root==null) return false;        Queue&lt;Node&lt;E&gt;&gt; queue=new LinkedList&lt;&gt;();        queue.offer(root);        boolean left=false;        while (!queue.isEmpty())&#123;            Node&lt;E&gt; node = queue.poll();            if (left&amp;&amp; !node.ifLeft()) return false;            if (node.left!=null)&#123;                queue.offer(node.left);            &#125;else if (node.right!=null)&#123;  //node.left==null &amp;&amp; node.right!= null                return false;            &#125;            if (node.right!=null)&#123;                queue.offer(node.right);            &#125;else &#123;  //node.left==null&amp;&amp;node.right==null  或者 node.left!=null &amp;&amp; node.right==null                     //也就是接下来的节点为叶子节点                left=true;            &#125;        &#125;        return true;    &#125;    public boolean contains(E element)&#123;        return node(element)!=null;    &#125;    private Node&lt;E&gt; node(E element) &#123;        Node&lt;E&gt; node = root;        while (node != null) &#123;            int cmp = compare(element, node.element);            if (cmp == 0) return node;            if (cmp &gt; 0) &#123;                node = node.right;            &#125; else &#123; // cmp &lt; 0                node = node.left;            &#125;        &#125;        return null;    &#125;    /**     * 找到中序遍历的前驱节点     * @param node     * @return     */    public Node&lt;E&gt; predecessor(Node&lt;E&gt; node)&#123;        if(node==null) return null;        //前驱在左子树，查找方式node.left.right.right.....        if (node.left!=null)&#123;            Node&lt;E&gt; p=node.left;            while (p.right!=null)&#123;                p=p.right;            &#125;            return p;        &#125;        while (node.parent!=null&amp;&amp;node==node.parent.left)&#123;            node=node.parent;        &#125;        return node.parent;    &#125;    /**     * h后继节点     * @param node     * @return     */    public Node&lt;E&gt; successor(Node&lt;E&gt; node)&#123; if(node==null) return null;        //前驱在左子树，查找方式node.right.left.left.....        if (node.right!=null)&#123;            Node&lt;E&gt; p=node.right;            while (p.left!=null)&#123;                p=p.left;            &#125;            return p;        &#125;        while (node.parent!=null&amp;&amp;node==node.parent.right)&#123;            node=node.parent;        &#125;        return node.parent;    &#125;    /**     * 删除节点     *      叶子节点： 左叶子节点  node==node.parent.left  =&gt;node.parent.left=null     *               右叶子节点 node==node.parent.right  =&gt;node.parent.right=null     *               node.parent==null 也就是根节点  =&gt;root=null     *     *      度为一的节点：也就是左孩子和右孩子有一个不存在 ，还有根节点的特殊情况     *      替换的节点为child    child=node.left   或者  child=node.right     *              1.右孩子不存在： child.parent=node.parent     *                          node.parent.left=child     *              2.左孩子不存在：     *                          child.parent=node.parent     *                          node.parent.right=child;     *              3.删除的节点是根节点：     *                          root=child     *                          child.parent=null;     *     *     度为2的节点: step1.找到删除节点的前驱或者后继节点     *                step2.让前驱或者后继节点的值覆盖删除的节点，     *                step3.删除前驱或者后继节点     *                (度为2的前驱或者后继节点的度为1或者0，也就是删除度为2的节点，真正删除的是他的前驱或者后继)     *     *     * @param element     */    public void remove(E element)&#123;        remove(node(element));    &#125;    private void remove(Node&lt;E&gt; node)&#123;        if(node==null) return;        size--;        if (node.haveTwoChildren())&#123; //度为二的点            Node&lt;E&gt; successor = successor(node);  //后继节点            node.element=successor.element;            node=successor; // 删除的节点为node        &#125;        //node 节点的度为0或者度为1        //度为1时replacement为替换的节点 ，度为0时replacement为null        Node&lt;E&gt; replacement=node.left != null ? node.left : node.right;        if (replacement != null) &#123; //即度为1            replacement.parent = node.parent;            if (node.parent == null) &#123; //node度为1的跟节点                root = replacement;            &#125; else if (node.parent.left == node) &#123; //node在父节点的左边                node.parent.left = replacement;            &#125; else &#123; // node 在夫节点的右边                node.parent.right = replacement;            &#125;        &#125;else if(node.parent==null) &#123; //叶子节点也是根节点            root=null;        &#125;else &#123; //度为0 也就是叶子节点            if (node.parent.left==node)&#123;                node.parent.left=null;            &#125;else &#123;                node.parent.right=null;            &#125;        &#125;    &#125;    /**     * 打印树     * @return     */    @Override    public Object root() &#123;        return root;    &#125;    @Override    public Object left(Object node) &#123;        return ((Node&lt;E&gt;)node).left;    &#125;    @Override    public Object right(Object node) &#123;        return ((Node&lt;E&gt;)node).right;    &#125;    @Override    public Object string(Object node) &#123;        return ((Node&lt;E&gt;)node).element;    &#125;&#125;\n\n测试package priv.kun._07_binarySearchTree;import org.junit.Test;import priv.kun._07_binarySearchTree.printer.BinaryTrees;/** * @author likun * @Package priv.kun._07_binarySearchTree * @Description: * @date 2021/9/20 21:49 */public class test &#123;    @Test    public void test1()&#123;        BinarySearchTree&lt;Integer&gt; tree = new BinarySearchTree&lt;&gt;();        tree.add(5);        tree.add(3);        tree.add(12);        tree.add(2);        tree.add(21);        BinaryTrees.print(tree);        System.out.println();        //tree.preorderTraversal();        System.out.println(&quot;--------&quot;);        tree.levelOrderTraversal(new BinarySearchTree.Visitor&lt;Integer&gt;() &#123;            @Override            public Boolean visit(Integer element) &#123;                System.out.println(element);                if (element==3)return true;                return false;            &#125;        &#125;);        System.out.println(&quot;--------&quot;);        tree.preorderTraversal(new BinarySearchTree.Visitor&lt;Integer&gt;() &#123;            @Override            public Boolean visit(Integer element) &#123;                System.out.print(element);                if (element==2) return true;                return false;            &#125;        &#125;);        System.out.println(&quot;\\n--------&quot;);        tree.inorderTraversal(new BinarySearchTree.Visitor&lt;Integer&gt;() &#123;            @Override            public Boolean visit(Integer element) &#123;                System.out.println(element);                if (element==12) return true;                return false;            &#125;        &#125;);        System.out.println(&quot;+++++++++++++&quot;);        System.out.println(tree.height());        System.out.println(tree.height2());        System.out.println(tree.isComplete());        System.out.println(tree.isComplete2());        System.out.println(&quot;+++++++++++++&quot;);    &#125;    @Test    public  void testRemove()&#123;        BinarySearchTree&lt;Integer&gt; tree = new BinarySearchTree&lt;&gt;();        tree.add(5);        tree.add(3);        tree.add(12);        tree.add(2);        tree.add(21);        tree.add(54);        tree.add(6);        tree.add(7);        tree.add(1);        BinaryTrees.print(tree);//        tree.remove(12);//        tree.remove(7);        tree.remove(6);//        tree.remove(54);        System.out.println();        BinaryTrees.print(tree);    &#125;&#125;","categories":["数据结构"],"tags":["树"]},{"title":"栈","url":"/2021/09/30/StackPractice/","content":"栈栈是一种运算受限的线性表，是一种先进后出(后进先出)（LIFO）的数据结构，限定只能在一端进行插入和删除操作，允许操作的一端称为栈顶，不允许操作的称为栈底\n栈的两种存储结构顺序栈和链栈，他们的存储结构不同，顺序栈是静态分配的，而链栈则是动态分配的，链栈可以将很多零碎的空间利用起来，容量可变，节省空间，顺序栈则固定内存空间，容量不变\n栈的应用递归调用，子程序调用，逆波兰表达式，浏览器的前进后退 等\n栈的实现Java实现 对于java的实现可以继承SingLinkedList，并且暴漏出一部分接口，就是一个简单链栈的实现了\nC 的简单实现 （进栈和出栈） #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define OK   1#define ERROR   0#define TRUE  1#define FALSE  0#define OVERFLOW   -2typedef  int  ElemType;typedef  int  Status;/** * 栈的出栈和入栈的基本实现 *///----- 栈的顺序存储表示 -----#define STACK_INIT_SIZE 3 // 存储空间的初始分配量#define STACKINCREMENT 3// 存储空间的分配增量typedef struct &#123;    ElemType *base;     int top;   //栈顶    int size;  //容量    int increment; // 扩容时，增加的存储容量 &#125; SqStack;// 构造一个空栈 SStatus InitStack(SqStack &amp;S)&#123;    S.base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));    if(!S.base) exit (OVERFLOW);    S.top = 0;    S.size = STACK_INIT_SIZE;    S.increment = STACKINCREMENT;    return OK;&#125;// 判栈 S 是否为空栈Status StackEmpty(SqStack S)&#123;    if (S.top==0) return  TRUE;    else return  FALSE;&#125;//入栈函数Status Push (SqStack &amp;S, ElemType e)&#123;        ElemType* newbase;    if(S.top&gt;=S.size)&#123;        newbase=(ElemType *) realloc(S.base,(S.size+S.increment)*sizeof(ElemType));        if (NULL==newbase) return OVERFLOW;        S.base=newbase;        S.size=S.size+S.increment;        printf(&quot;已扩容：size为：%d \\n&quot;,S.size);    &#125;    S.base[S.top]=e;        S.top++;    return OK;&#125;//出栈函数Status Pop (SqStack &amp;S, ElemType &amp;e) &#123;    if(StackEmpty(S)) return ERROR; //栈是否为空    e=S.base[S.top-1];    S.top--;    S.size--;    return OK;    &#125;//输出顺序栈函数void OutStack(SqStack S)&#123;      ElemType  e=S.base[S.top-1];       if(TRUE == StackEmpty(S))&#123;        printf(&quot;这是一个空栈！&quot;);    &#125;else&#123;        while(FALSE == StackEmpty(S))&#123;\t\t\tPop(S,e);\t\t\tprintf(&quot;%6d&quot;, e);        &#125;    &#125;\t\tprintf(&quot;\\n&quot;);&#125;//主函数int main()&#123; \t    SqStack s;    int cord; ElemType a;    printf(&quot;第一次使用必须初始化！\\n&quot;);    do&#123;        printf(&quot;\\n 主菜单 \\n&quot;);        printf(&quot; 1 初始化顺序栈 &quot;);        printf(&quot; 2 插入一个元素 &quot;);        printf(&quot; 3 删除栈顶元素 &quot;);        printf(&quot; 4 结束程序运行 &quot;);        printf(&quot;\\n-------------------------------------------------------------------\\n&quot;);        printf(&quot;请输入您的选择( 1, 2, 3, 4)&quot;);        scanf(&quot;%d&quot;,&amp;cord);        printf(&quot;\\n&quot;);        switch(cord)            &#123;                case 1:                    InitStack(s);                    OutStack(s);                    break;                case 2:                    printf(&quot;请输入要插入的数据元素：a=&quot;);                    scanf(&quot;%d&quot;,&amp;a);                    Push(s,a);                    printf(&quot;%d 进栈之后的栈：&quot;,a);                    OutStack(s);                    break;                case 3:                    Pop(s,a);                    printf(&quot;栈顶元素 %d 出栈之后的栈：&quot;,a);                    OutStack(s);                    break;                case 4:                    exit(0);            &#125;    &#125;while (cord&lt;=4);    return 0;&#125;  \n\n测试\n一些应用进制转换  #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#define OK 1#define ERROR 0#define TRUE  1#define FALSE  0#define OVERFLOW -2typedef int ElemType;typedef int Status;#define STACK_INIT_SIZE 10#define STACKINCREMENT 5/** * 栈实现进制转换 */typedef struct &#123;    ElemType *base;    int top;    int size;    int increment; // 扩容时，增加的存储容量 &#125; SqStack;// 构造一个空栈 SStatus InitStack(SqStack &amp;S)&#123;    S.base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));    if(!S.base) exit (OVERFLOW);    S.top = 0;    S.size = STACK_INIT_SIZE;    S.increment = STACKINCREMENT;    return OK;&#125;// 判栈 S 是否为空栈Status StackEmpty(SqStack S) &#123;    if (S.top==0) return   TRUE;    else return   FALSE;&#125;//入栈函数Status Push (SqStack &amp;S, ElemType e) &#123;  ElemType* newbase;    if(S.top&gt;=S.size)&#123;        newbase=(ElemType *) realloc(S.base,(S.size+S.increment)*sizeof(ElemType));        if (NULL==newbase) return OVERFLOW;        S.base=newbase;        S.size=S.size+S.increment;        printf(&quot;已扩容：size为：%d \\n&quot;,S.size);    &#125;    S.base[S.top]=e;        S.top++;    return OK;&#125;//出栈函数Status Pop (SqStack &amp;S, ElemType &amp;e) &#123;    if(StackEmpty(S)) return ERROR; //栈是否为空    e=S.base[S.top-1];    S.top--;    S.size--;    return OK;    &#125;//十进制转八进制函数void conversion(int num,int conver)&#123;     SqStack S;    //int  n,d;    ElemType e;    InitStack(S); //初始栈    while (num != 0) &#123;        int temp = num % conver;        Push(S,temp);        num = num / conver;    &#125;    while (FALSE==StackEmpty(S))&#123;        Pop(S,e);        printf(&quot;%6d&quot;,e);    &#125;        &#125;int  main()&#123;    int num,conver;    char c=0;        while(c!=(27))  //ESC　退出     &#123;        printf(&quot;\\n随意键入，按ESC，退出程序。\\n&quot;);        c=getch();        if (c==(27))&#123;            break;        &#125;                printf(&quot;输入一个数字：&quot;);        scanf(&quot;%d&quot;,&amp;num);        printf(&quot;转换为几进制：&quot;);        scanf(&quot;%d&quot;,&amp;conver);        conversion(num,conver);    &#125;     printf(&quot;退出...\\n&quot;);    //  do&#123;    //     printf(&quot;输入一个数字：&quot;);    //     scanf(&quot;%d&quot;,&amp;num);    //     printf(&quot;转换为几进制：&quot;);    //     scanf(&quot;%d&quot;,&amp;conver);    //     conversion(num,conver);    // &#125;while (true);    return 0;&#125; \n测试 \n括号匹配  #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define OK 1#define ERROR 0#define TRUE  1#define FALSE  0#define OVERFLOW -2typedef int ElemType;typedef int Status;#define STACK_INIT_SIZE 10#define STACKINCREMENT 5typedef struct &#123;    ElemType *base;    int top;    int size;    int increment;  &#125; SqStack;Status InitStack(SqStack &amp;S)&#123;    S.base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));    if(!S.base) exit (OVERFLOW);    S.top = 0;    S.size = STACK_INIT_SIZE;    S.increment = STACKINCREMENT;    return OK;&#125;Status StackEmpty(SqStack S) &#123;    if (S.top==0) return   TRUE;    else return   FALSE;&#125;Status Push (SqStack &amp;S, ElemType e) &#123;  ElemType* newbase;    if(S.top&gt;=S.size)&#123;        newbase=(ElemType *) realloc(S.base,(S.size+S.increment)*sizeof(ElemType));        if (NULL==newbase) return OVERFLOW;        S.base=newbase;        S.size=S.size+S.increment;        printf(&quot;已扩容：size为：%d \\n&quot;,S.size);    &#125;    S.base[S.top]=e;        S.top++;    return OK;&#125;Status Pop (SqStack &amp;S, ElemType &amp;e) &#123;    if(StackEmpty(S)) return ERROR;     e=S.base[S.top-1];    S.top--;    S.size--;    return OK;    &#125;Status Matching(char c[])&#123;    SqStack S;    ElemType e;    InitStack(S);    //puts(c);    char* string = c;    for (int i = 0; i &lt; strlen(string); i++)    &#123;        if (c[i]==&#x27;[&#x27;||c[i]==&#x27;(&#x27;)&#123;            Push(S,c[i]);        &#125; else &#123;            if(TRUE== StackEmpty(S)) &#123;                printf(&quot;不比配&quot;);                return ERROR;            &#125;             if (c[i]==&#x27;]&#x27;||c[i]==&#x27;)&#x27;)&#123;                Pop(S,e);                if (c[i]==&#x27;)&#x27; &amp;&amp; e !=&#x27;(&#x27;)&#123;                    printf(&quot;不比配&quot;);                    return ERROR;                &#125;                if (c[i]==&#x27;]&#x27;&amp;&amp;  e !=&#x27;[&#x27;) &#123;                    printf(&quot;不比配&quot;);                    return ERROR;                &#125;            &#125;        &#125;            &#125;    if (TRUE==StackEmpty(S))     &#123;        printf(&quot;匹配。。。。。。&quot;);        return OK;    &#125;        printf(&quot;不比配&quot;);    return ERROR;&#125;int main()&#123;    char c[100];    printf(&quot;请输入仅包含（ [ ] ) 的字符串\\n&quot;);    gets(c);    Matching(c);   // puts(c);    return 0;&#125; \n测试 \n","categories":["数据结构"],"tags":["栈"]}]