[{"title":"单链表基本操作实现","url":"/2021/09/19/SingleLinkedList/","content":"链表链表的基本概念链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的，链表每个节点有两部分分组成，一个是数据域（也就是该元素的数据信息）用element表示，一个是指针域（与就是对于下一个节点的引用）用next表示；\n链表的设计与实现\n接口设计/** * 清除所有元素 */void clear();/** * 元素的数量 * @return */int size();/** * 是否为空 * @return */boolean isEmpty();/** * 是否包含某个元素 * @param element * @return */boolean contains(E element);/** * 添加元素到尾部 * @param element */void add(E element);/** * 获取index位置的元素 * @param index * @return */E get(int index);/** * 设置index位置的元素 * @param index * @param element * @return 原来的元素ֵ */E set(int index, E element);/** * 在index位置插入一个元素 * @param index * @param element */void add(int index, E element);/** * 删除index位置的元素 * @param index * @return */E remove(int index);/** * 查看元素的索引 * @param element * @return */int indexOf(E element);\n\n接口的实现package priv.kun.LinkedList;/** * @author likun * @Package priv.kun.LinkedList * @Description: * @date */public class SingleLinkedList&lt;E&gt; &#123;    private int size; //元素的数量    private Node&lt;E&gt; first; //头节点    private static class Node&lt;E&gt;&#123;        E element;        Node&lt;E&gt; next;        public Node(E element,Node&lt;E&gt; next)&#123;            this.element=element;            this.next=next;        &#125;    &#125;    /**     * 清空     * size设置为0 ，头节点为null     */    public void clear() &#123;        size=0;        first=null;    &#125;    /**     * 元素的数量     * @return     */    public int size() &#123;        return size;    &#125;    /**     * 是否为空     * @return     */    public boolean isEmpty() &#123;        return size==0;    &#125;    /**     * 返回某个元素的位置     * @param element     * @return     */    public int indexOf(E element) &#123;        if (element==null)&#123;            Node&lt;E&gt; node=first;            for (int i=0;i&lt;size;i++)&#123;                if (node.element==null) return i;                node=node.next;            &#125;        &#125;else &#123;            Node&lt;E&gt; node=first;            for (int i=0;i&lt;size;i++)&#123;                if (element.equals(node.element)) return i;                node=node.next;            &#125;        &#125;        return -1;    &#125;    /**     * 是否包含某个元素     * @param element     * @return     */    public boolean contains(E element) &#123;        return indexOf(element) != -1;    &#125;    /**     * 在尾部添加元素     * @param element     */    public void add(E element) &#123;        add(size,element);    &#125;    /**     * 在index位置添加元素     * @param index     * @param element     */    public void add(int index, E element) &#123;        if (index == 0) &#123;            first = new Node&lt;&gt;(element, null);        &#125; else &#123;            Node&lt;E&gt; prev = node(index - 1);            prev.next = new Node&lt;&gt;(element, prev.next);        &#125;        size++;    &#125;    /**     * 返回 index位置的元素     * @param index     * @return     */    public E get(int index) &#123;        return node(index).element;    &#125;    /**     * 返回某个位置节点     * @param index     * @return     */    public Node&lt;E&gt; node(int index)&#123;        Node&lt;E&gt; node=first;        for (int i=0;i&lt;index;i++)&#123;            node=node.next;        &#125;        return node;    &#125;    /**     * 设置index位置的元素     * @param index     * @param element     * @return     */    public E set(int index, E element) &#123;        Node&lt;E&gt; node = node(index); //找到index 位置的节点        E oldElement = node.element;        node.element=element;        return oldElement;    &#125;    /**     * 删除 index位置的元素     * @param index     * @return     */    public E remove(int index) &#123;        Node&lt;E&gt; node = node(index);//删除的节点        if (index==0)&#123; //删除的是第一个节点            first=node.next;        &#125; else &#123;            Node&lt;E&gt; prev = node(index - 1); //删除的前一个节点            Node&lt;E&gt; next = node.next; //删除节点的后一个节点            prev.next=next; //        &#125;        size--;        return node.element;    &#125;    @Override    public String toString() &#123;        StringBuilder stringBuilder = new StringBuilder();        stringBuilder.append(&quot;size:&quot;).append(size).append(&quot; ,[&quot;);        Node&lt;E&gt; node=first;        for (int i=0;i&lt;size;i++)&#123;            if (i!=0)&#123;                stringBuilder.append(&quot;,&quot;);            &#125;            stringBuilder.append(node.element);            node=node.next;        &#125;        stringBuilder.append(&quot;]&quot;);        return stringBuilder.toString();    &#125;&#125;\n\n测试@Test   public void test1()&#123;       SingleLinkedList&lt;Integer&gt; list = new SingleLinkedList&lt;&gt;();       list.add(1);       list.add(2);       list.set(0,111);       System.out.println(list.get(0));       System.out.println(list);   &#125;\n\n这里的实现并没有做一些非法参数传入入的处理，例如node(-5),这一看就不合理，默认先认为传入的数据都是合理的，并且有一些错误java就可以抛出异常。\n（实现的可能有错误，或者不合理的地方，等发现在修改）\nC语言实现链表实现思路和上面一样，\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /*     定义结构 */typedef struct Node&#123;    int  element;   //c语言中好像没有泛型，默认就是int类型的元素      struct Node *next;&#125;Node;Node* init();Node* add(Node* frist,int element); //添加节点Node* addForIndex(Node* first,int index,int element); //添加节点在index位置Node* findNode(Node* frist,int index);  //查找index位置的节点void display(Node *p);  //打印Node* del(Node *first,int index);  //删除index位置的节点Node* clear(Node* first); //清空//Node *first; //定义单链表的头指针int size=0; //元素数量Node* init()&#123;    Node * first;    first=NULL;    return first;&#125;/* 添加节点 */Node* add(Node* first,int element)&#123;    return addForIndex(first,size,element);&#125;/* 在index位置添加节点 */Node* addForIndex(Node* first,int index,int element)&#123;    if(size==0)&#123;        Node *c=(Node*)malloc(sizeof(Node));  //分配一个节点，并让指针p指向这个节点        first=c;      /*   first-&gt;element=element;        first-&gt;next=NULL; */        first-&gt; element=element;        first-&gt; next=NULL;     &#125;else&#123;        Node *c=(Node*)malloc(sizeof(Node));  //添加的节点        Node *prev=findNode(first,index-1);  //添加节点的前一个节点        c-&gt; element=element;        c-&gt; next=prev-&gt;next;        prev-&gt;next=c;    &#125;    size++;    return first;&#125;Node* findNode(Node* first,int index)&#123;    Node *temp=first;    for(int i=0;i&lt;index;i++)&#123;        temp=temp-&gt;next;    &#125; /*     Node *c=(Node*)malloc(sizeof(Node)); */    return temp;&#125;void display(Node *p)&#123;    Node* temp=p;    while (temp!=NULL) &#123;        printf(&quot;%d &quot;,temp-&gt;element);        temp=temp-&gt;next;    &#125;    printf(&quot;\\n&quot;);    printf(&quot;size=%d&quot;,size);    printf(&quot;\\n&quot;);&#125;/** * 删除节点 */Node* del(Node* first,int index)&#123;    Node *del=findNode(first,index); //删除的节点    if(index==0)&#123;        first=del-&gt;next;    &#125;else&#123;        Node *prev=findNode(first,index-1);        prev-&gt;next=prev-&gt;next-&gt;next;    &#125;    free(del);    size--;    return first;&#125;Node* clear(Node* first)&#123;    int temp=size;    for(int i=0;i&lt;temp;i++)&#123;        del(first,0);    &#125;    size=0;    return first;&#125;void main()&#123;    // add(2);    // add(3);    // add(4);    // addForIndex(3,6);    // //clear();    // add(5644);    // /* del(0);    // del(3); */    // del(0);    // del(0);    // del(0);    // clear();    // add(123);    // display(first);   /*  Node *c=findNode(2);    printf(&quot;%d&quot;,c-&gt;element); */     Node* first=init();   first=add(first,1);   first=add(first,3);   first=del(first,0);   clear(first);   first=add(first,123);    display(first);     printf(&quot;\\nthis is main&quot;);&#125;\n\n","categories":["数据结构"],"tags":["链表"]},{"title":"二叉搜索树基本操作实现","url":"/2021/09/24/BinarySearchTree/","content":"二叉搜索树package priv.kun._07_binarySearchTree;import priv.kun._07_binarySearchTree.printer.BinaryTreeInfo;import java.util.Comparator;import java.util.LinkedList;import java.util.Queue;/** * @author likun * @Package priv.kun._07_binarySearchTree * @Description: * @date  */public class BinarySearchTree&lt;E&gt; implements BinaryTreeInfo &#123;    private int size;    private Node&lt;E&gt; root; //根节点    private Comparator&lt;E&gt; comparator; //比较器， 从外部传入    public BinarySearchTree()&#123;        this(null);    &#125;    public BinarySearchTree(Comparator&lt;E&gt; comparator)&#123;        this.comparator=comparator;    &#125;    private static class Node&lt;E&gt;&#123;        E element;        Node&lt;E&gt; left;        Node&lt;E&gt; right;        Node&lt;E&gt; parent;        public Node(E element,Node parent)&#123;            this.element=element;            this.parent=parent;        &#125;        /**         *         * @return         */        public boolean ifLeft()&#123;            return left == null &amp;&amp; right == null;        &#125;        public boolean haveTwoChildren()&#123;            return left!=null&amp;&amp;right!=null;        &#125;    &#125;    public int size()&#123;        return 0;    &#125;    public boolean isEmpty()&#123;        return size==0;    &#125;    public void clear()&#123;        root=null;        size=0;    &#125;    public static abstract class Visitor&lt;E&gt;&#123;        boolean stop;        public abstract Boolean visit(E element);    &#125;    /**     * 前序遍历     *  递归实现     */    public void preorderTraversal(Visitor&lt;E&gt; visitor)&#123;        preorderTraversal(root,visitor);    &#125;    private void preorderTraversal(Node&lt;E&gt; node,Visitor&lt;E&gt; visitor)&#123;        if (node==null||visitor.stop) return;        visitor.stop=visitor.visit(node.element);        preorderTraversal(node.left,visitor);        preorderTraversal(node.right,visitor);    &#125;    /**     * 中序遍历     */    public void inorderTraversal(Visitor&lt;E&gt; visitor)&#123;        if (visitor==null) return;        inorderTraversal(root,visitor);    &#125;    private void inorderTraversal(Node&lt;E&gt; node,Visitor&lt;E&gt; visitor)&#123;        if (node==null||visitor.stop) return;        inorderTraversal(node.left,visitor);        if (visitor.stop) return;        visitor.stop = visitor.visit(node.element);        inorderTraversal(node.right,visitor);    &#125;    /**     * 后序遍历     */    public void postorderTraversal(Visitor&lt;E&gt; visitor)&#123;        if (visitor==null) return;        postorderTraversal(root,visitor);    &#125;    private void postorderTraversal(Node&lt;E&gt; node,Visitor visitor)&#123;        if (node==null||visitor.stop) return;        postorderTraversal(node.left,visitor);        postorderTraversal(node.right,visitor);        if (visitor.stop) return;        visitor.stop= visitor.visit(node.element);    &#125;    /**     * 层序遍历     */    public void levelOrderTraversal(Visitor&lt;E&gt; visitor)&#123;        if (root==null) return;        Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root); //入队        while (!queue.isEmpty())&#123;            Node&lt;E&gt; node = queue.poll();//出队            Boolean aBoolean = visitor.visit(node.element);            if (aBoolean) return;            if (node.left!=null)&#123;                queue.offer(node.left);            &#125;            if (node.right!=null)&#123;                queue.offer(node.right);            &#125;        &#125;    &#125;    /**     * 添加节点     * @param element     */    public void add(E element)&#123;        elementNotNullCheck(element);        if (root==null)&#123; //添加根节点            root=new Node&lt;E&gt;(element,null);            size++;            return;        &#125;        //添加执行到这里没有返回的话，添加的就不是根节点        Node&lt;E&gt; parent=root;        Node&lt;E&gt; node=root;        int compare=0;        while (node!=null)&#123;             compare = compare(element, node.element);            parent=node;            if (compare&gt;0)&#123;                node=node.right;            &#125;else if(compare&lt;0)&#123;                node=node.left;            &#125;else &#123;                //等于0                node.element = element;                return;            &#125;        &#125;        //创建一个新的节点插入        Node&lt;E&gt; newNode = new Node&lt;&gt;(element, parent); //这个是新插入的节点        if(compare&gt;0)&#123;            // 插到父节点的右边            parent.right=newNode;        &#125;else &#123;            parent.left=newNode;        &#125;    &#125;    /**     *     * @param e1     * @param e2     * @return 返回值等于0 e1,e2相等     *          返回值大于0 e1大于e2     *          返回值小于0 e1小于e2     */    private int compare(E e1, E e2) &#123;        if (comparator!=null)&#123; //比较器不等null,也就是外部传入了一个比较规则            //用外部传入的规则比较            int compare = comparator.compare(e1, e2);            return compare;        &#125;        //没有穿比较器        //但是一定要有比较规则，将他强制转换，使用他默认的比较规则        int i = ((Comparable&lt;E&gt;) e1).compareTo(e2);        return i;    &#125;    /**     * 检查添加的节点是为空     * 如果元素为空，抛出异常 -》参数异常     * @param element     */    private void elementNotNullCheck(E element) &#123;        if (element==null)&#123;            throw new IllegalArgumentException(&quot;element不能为空&quot;);  //非法参数异常        &#125;    &#125;    /**     * 树的高度 递归     *  （树的高度，就是根节点的高度）     * @return     */    public int height()&#123;        return height(root);    &#125;    private int height(Node&lt;E&gt; node)&#123;        if(node==null) return 0;        int max = Math.max(height(node.left), height(node.left));        return max+1;    &#125;    /**     * 树的高度，递归     * @return     */    public int height2()&#123;        if (root==null) return 0;        int height=0; //树高        int levelSize=1; // 每一层元素的数量        Queue&lt;Node&lt;E&gt;&gt; queue=new LinkedList&lt;&gt;();        queue.offer(root); //入队        while (!queue.isEmpty())&#123;            Node&lt;E&gt; node = queue.poll();            levelSize--;            if (node.left!=null)&#123;                queue.offer(node.left);            &#125;            if (node.right!=null)&#123;                queue.offer(node.right);            &#125;            if (levelSize==0)&#123;                levelSize=queue.size();                height++;            &#125;        &#125;        return height;    &#125;    /**     * 判断是否为完全二叉树     *     *  node.left!=null&amp;&amp;node.right!=null  不是叶子节点，继续进栈出栈操作     *  node.left==null&amp;&amp; node.right!=null 不是二叉树 返回false     *  node.left==null &amp;&amp; node.right==null  和     *  node.left==null &amp;&amp; node.right==null  这两个即为叶子节点，之后在遍历到的节点均不能再有子节点，则是完全二叉树，否则为false     *     *     * @return true：完全二叉树        false:不是完全二叉树     */    public boolean isComplete()&#123;        if (root==null) return false;        Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root); //        boolean left=false; //        while (!queue.isEmpty())&#123;            Node&lt;E&gt; node = queue.poll();            if (left &amp;&amp; !node.ifLeft()) return false;            if (node.haveTwoChildren())&#123;                queue.offer(node.left);                queue.offer(node.right);            &#125;else if (node.left==null &amp;&amp;node.left!=null)&#123;                return false;            &#125;else &#123;                //侯面的节点都是叶子节点                left=true;                if (node.left!=null)&#123;                        queue.offer(node.left);                &#125;            &#125;        &#125;        return  true;    &#125;    /**     * 判断是否为完全二叉树     * @return     */    public boolean isComplete2()&#123;        if (root==null) return false;        Queue&lt;Node&lt;E&gt;&gt; queue=new LinkedList&lt;&gt;();        queue.offer(root);        boolean left=false;        while (!queue.isEmpty())&#123;            Node&lt;E&gt; node = queue.poll();            if (left&amp;&amp; !node.ifLeft()) return false;            if (node.left!=null)&#123;                queue.offer(node.left);            &#125;else if (node.right!=null)&#123;  //node.left==null &amp;&amp; node.right!= null                return false;            &#125;            if (node.right!=null)&#123;                queue.offer(node.right);            &#125;else &#123;  //node.left==null&amp;&amp;node.right==null  或者 node.left!=null &amp;&amp; node.right==null                     //也就是接下来的节点为叶子节点                left=true;            &#125;        &#125;        return true;    &#125;    public boolean contains(E element)&#123;        return node(element)!=null;    &#125;    private Node&lt;E&gt; node(E element) &#123;        Node&lt;E&gt; node = root;        while (node != null) &#123;            int cmp = compare(element, node.element);            if (cmp == 0) return node;            if (cmp &gt; 0) &#123;                node = node.right;            &#125; else &#123; // cmp &lt; 0                node = node.left;            &#125;        &#125;        return null;    &#125;    /**     * 找到中序遍历的前驱节点     * @param node     * @return     */    public Node&lt;E&gt; predecessor(Node&lt;E&gt; node)&#123;        if(node==null) return null;        //前驱在左子树，查找方式node.left.right.right.....        if (node.left!=null)&#123;            Node&lt;E&gt; p=node.left;            while (p.right!=null)&#123;                p=p.right;            &#125;            return p;        &#125;        while (node.parent!=null&amp;&amp;node==node.parent.left)&#123;            node=node.parent;        &#125;        return node.parent;    &#125;    /**     * h后继节点     * @param node     * @return     */    public Node&lt;E&gt; successor(Node&lt;E&gt; node)&#123; if(node==null) return null;        //前驱在左子树，查找方式node.right.left.left.....        if (node.right!=null)&#123;            Node&lt;E&gt; p=node.right;            while (p.left!=null)&#123;                p=p.left;            &#125;            return p;        &#125;        while (node.parent!=null&amp;&amp;node==node.parent.right)&#123;            node=node.parent;        &#125;        return node.parent;    &#125;    /**     * 删除节点     *      叶子节点： 左叶子节点  node==node.parent.left  =&gt;node.parent.left=null     *               右叶子节点 node==node.parent.right  =&gt;node.parent.right=null     *               node.parent==null 也就是根节点  =&gt;root=null     *     *      度为一的节点：也就是左孩子和右孩子有一个不存在 ，还有根节点的特殊情况     *      替换的节点为child    child=node.left   或者  child=node.right     *              1.右孩子不存在： child.parent=node.parent     *                          node.parent.left=child     *              2.左孩子不存在：     *                          child.parent=node.parent     *                          node.parent.right=child;     *              3.删除的节点是根节点：     *                          root=child     *                          child.parent=null;     *     *     度为2的节点: step1.找到删除节点的前驱或者后继节点     *                step2.让前驱或者后继节点的值覆盖删除的节点，     *                step3.删除前驱或者后继节点     *                (度为2的前驱或者后继节点的度为1或者0，也就是删除度为2的节点，真正删除的是他的前驱或者后继)     *     *     * @param element     */    public void remove(E element)&#123;        remove(node(element));    &#125;    private void remove(Node&lt;E&gt; node)&#123;        if(node==null) return;        size--;        if (node.haveTwoChildren())&#123; //度为二的点            Node&lt;E&gt; successor = successor(node);  //后继节点            node.element=successor.element;            node=successor; // 删除的节点为node        &#125;        //node 节点的度为0或者度为1        //度为1时replacement为替换的节点 ，度为0时replacement为null        Node&lt;E&gt; replacement=node.left != null ? node.left : node.right;        if (replacement != null) &#123; //即度为1            replacement.parent = node.parent;            if (node.parent == null) &#123; //node度为1的跟节点                root = replacement;            &#125; else if (node.parent.left == node) &#123; //node在父节点的左边                node.parent.left = replacement;            &#125; else &#123; // node 在夫节点的右边                node.parent.right = replacement;            &#125;        &#125;else if(node.parent==null) &#123; //叶子节点也是根节点            root=null;        &#125;else &#123; //度为0 也就是叶子节点            if (node.parent.left==node)&#123;                node.parent.left=null;            &#125;else &#123;                node.parent.right=null;            &#125;        &#125;    &#125;    /**     * 打印树     * @return     */    @Override    public Object root() &#123;        return root;    &#125;    @Override    public Object left(Object node) &#123;        return ((Node&lt;E&gt;)node).left;    &#125;    @Override    public Object right(Object node) &#123;        return ((Node&lt;E&gt;)node).right;    &#125;    @Override    public Object string(Object node) &#123;        return ((Node&lt;E&gt;)node).element;    &#125;&#125;\n\n测试package priv.kun._07_binarySearchTree;import org.junit.Test;import priv.kun._07_binarySearchTree.printer.BinaryTrees;/** * @author likun * @Package priv.kun._07_binarySearchTree * @Description: * @date 2021/9/20 21:49 */public class test &#123;    @Test    public void test1()&#123;        BinarySearchTree&lt;Integer&gt; tree = new BinarySearchTree&lt;&gt;();        tree.add(5);        tree.add(3);        tree.add(12);        tree.add(2);        tree.add(21);        BinaryTrees.print(tree);        System.out.println();        //tree.preorderTraversal();        System.out.println(&quot;--------&quot;);        tree.levelOrderTraversal(new BinarySearchTree.Visitor&lt;Integer&gt;() &#123;            @Override            public Boolean visit(Integer element) &#123;                System.out.println(element);                if (element==3)return true;                return false;            &#125;        &#125;);        System.out.println(&quot;--------&quot;);        tree.preorderTraversal(new BinarySearchTree.Visitor&lt;Integer&gt;() &#123;            @Override            public Boolean visit(Integer element) &#123;                System.out.print(element);                if (element==2) return true;                return false;            &#125;        &#125;);        System.out.println(&quot;\\n--------&quot;);        tree.inorderTraversal(new BinarySearchTree.Visitor&lt;Integer&gt;() &#123;            @Override            public Boolean visit(Integer element) &#123;                System.out.println(element);                if (element==12) return true;                return false;            &#125;        &#125;);        System.out.println(&quot;+++++++++++++&quot;);        System.out.println(tree.height());        System.out.println(tree.height2());        System.out.println(tree.isComplete());        System.out.println(tree.isComplete2());        System.out.println(&quot;+++++++++++++&quot;);    &#125;    @Test    public  void testRemove()&#123;        BinarySearchTree&lt;Integer&gt; tree = new BinarySearchTree&lt;&gt;();        tree.add(5);        tree.add(3);        tree.add(12);        tree.add(2);        tree.add(21);        tree.add(54);        tree.add(6);        tree.add(7);        tree.add(1);        BinaryTrees.print(tree);//        tree.remove(12);//        tree.remove(7);        tree.remove(6);//        tree.remove(54);        System.out.println();        BinaryTrees.print(tree);    &#125;&#125;","categories":["数据结构"],"tags":["树"]},{"title":"栈","url":"/2021/09/30/StackPractice/","content":"栈栈是一种运算受限的线性表，是一种先进后出(后进先出)（LIFO）的数据结构，限定只能在一端进行插入和删除操作，允许操作的一端称为栈顶，不允许操作的称为栈底\n栈的两种存储结构顺序栈和链栈，他们的存储结构不同，顺序栈是静态分配的，而链栈则是动态分配的，链栈可以将很多零碎的空间利用起来，容量可变，节省空间，顺序栈则固定内存空间，容量不变\n栈的应用递归调用，子程序调用，逆波兰表达式，树的遍历，浏览器的前进后退 等\n栈的实现Java实现 对于java的实现可以继承SingLinkedList，并且暴漏出一部分接口，就是一个简单链栈的实现了\nC 的简单实现 （进栈和出栈） #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define OK   1#define ERROR   0#define TRUE  1#define FALSE  0#define OVERFLOW   -2typedef  int  ElemType;typedef  int  Status;/** * 栈的出栈和入栈的基本实现 *///----- 栈的顺序存储表示 -----#define STACK_INIT_SIZE 3 // 存储空间的初始分配量#define STACKINCREMENT 3// 存储空间的分配增量typedef struct &#123;    ElemType *base;     int top;   //栈顶    int size;  //容量    int increment; // 扩容时，增加的存储容量 &#125; SqStack;// 构造一个空栈 SStatus InitStack(SqStack &amp;S)&#123;    S.base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));    if(!S.base) exit (OVERFLOW);    S.top = 0;    S.size = STACK_INIT_SIZE;    S.increment = STACKINCREMENT;    return OK;&#125;// 判栈 S 是否为空栈Status StackEmpty(SqStack S)&#123;    if (S.top==0) return  TRUE;    else return  FALSE;&#125;//入栈函数Status Push (SqStack &amp;S, ElemType e)&#123;        ElemType* newbase;    if(S.top&gt;=S.size)&#123;        newbase=(ElemType *) realloc(S.base,(S.size+S.increment)*sizeof(ElemType));        if (NULL==newbase) return OVERFLOW;        S.base=newbase;        S.size=S.size+S.increment;        printf(&quot;已扩容：size为：%d \\n&quot;,S.size);    &#125;    S.base[S.top]=e;        S.top++;    return OK;&#125;//出栈函数Status Pop (SqStack &amp;S, ElemType &amp;e) &#123;    if(StackEmpty(S)) return ERROR; //栈是否为空    e=S.base[S.top-1];    S.top--;    S.size--;    return OK;    &#125;//输出顺序栈函数void OutStack(SqStack S)&#123;      ElemType  e=S.base[S.top-1];       if(TRUE == StackEmpty(S))&#123;        printf(&quot;这是一个空栈！&quot;);    &#125;else&#123;        while(FALSE == StackEmpty(S))&#123;\t\t\tPop(S,e);\t\t\tprintf(&quot;%6d&quot;, e);        &#125;    &#125;\t\tprintf(&quot;\\n&quot;);&#125;//主函数int main()&#123; \t    SqStack s;    int cord; ElemType a;    printf(&quot;第一次使用必须初始化！\\n&quot;);    do&#123;        printf(&quot;\\n 主菜单 \\n&quot;);        printf(&quot; 1 初始化顺序栈 &quot;);        printf(&quot; 2 插入一个元素 &quot;);        printf(&quot; 3 删除栈顶元素 &quot;);        printf(&quot; 4 结束程序运行 &quot;);        printf(&quot;\\n-------------------------------------------------------------------\\n&quot;);        printf(&quot;请输入您的选择( 1, 2, 3, 4)&quot;);        scanf(&quot;%d&quot;,&amp;cord);        printf(&quot;\\n&quot;);        switch(cord)            &#123;                case 1:                    InitStack(s);                    OutStack(s);                    break;                case 2:                    printf(&quot;请输入要插入的数据元素：a=&quot;);                    scanf(&quot;%d&quot;,&amp;a);                    Push(s,a);                    printf(&quot;%d 进栈之后的栈：&quot;,a);                    OutStack(s);                    break;                case 3:                    Pop(s,a);                    printf(&quot;栈顶元素 %d 出栈之后的栈：&quot;,a);                    OutStack(s);                    break;                case 4:                    exit(0);            &#125;    &#125;while (cord&lt;=4);    return 0;&#125;  \n\n测试\n一些应用进制转换  #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#define OK 1#define ERROR 0#define TRUE  1#define FALSE  0#define OVERFLOW -2typedef int ElemType;typedef int Status;#define STACK_INIT_SIZE 10#define STACKINCREMENT 5/** * 栈实现进制转换 */typedef struct &#123;    ElemType *base;    int top;    int size;    int increment; // 扩容时，增加的存储容量 &#125; SqStack;// 构造一个空栈 SStatus InitStack(SqStack &amp;S)&#123;    S.base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));    if(!S.base) exit (OVERFLOW);    S.top = 0;    S.size = STACK_INIT_SIZE;    S.increment = STACKINCREMENT;    return OK;&#125;// 判栈 S 是否为空栈Status StackEmpty(SqStack S) &#123;    if (S.top==0) return   TRUE;    else return   FALSE;&#125;//入栈函数Status Push (SqStack &amp;S, ElemType e) &#123;  ElemType* newbase;    if(S.top&gt;=S.size)&#123;        newbase=(ElemType *) realloc(S.base,(S.size+S.increment)*sizeof(ElemType));        if (NULL==newbase) return OVERFLOW;        S.base=newbase;        S.size=S.size+S.increment;        printf(&quot;已扩容：size为：%d \\n&quot;,S.size);    &#125;    S.base[S.top]=e;        S.top++;    return OK;&#125;//出栈函数Status Pop (SqStack &amp;S, ElemType &amp;e) &#123;    if(StackEmpty(S)) return ERROR; //栈是否为空    e=S.base[S.top-1];    S.top--;    S.size--;    return OK;    &#125;//十进制转八进制函数void conversion(int num,int conver)&#123;     SqStack S;    //int  n,d;    ElemType e;    InitStack(S); //初始栈    while (num != 0) &#123;        int temp = num % conver;        Push(S,temp);        num = num / conver;    &#125;    while (FALSE==StackEmpty(S))&#123;        Pop(S,e);        printf(&quot;%6d&quot;,e);    &#125;        &#125;int  main()&#123;    int num,conver;    char c=0;        while(c!=(27))  //ESC　退出     &#123;        printf(&quot;\\n随意键入，按ESC，退出程序。\\n&quot;);        c=getch();        if (c==(27))&#123;            break;        &#125;                printf(&quot;输入一个数字：&quot;);        scanf(&quot;%d&quot;,&amp;num);        printf(&quot;转换为几进制：&quot;);        scanf(&quot;%d&quot;,&amp;conver);        conversion(num,conver);    &#125;     printf(&quot;退出...\\n&quot;);    //  do&#123;    //     printf(&quot;输入一个数字：&quot;);    //     scanf(&quot;%d&quot;,&amp;num);    //     printf(&quot;转换为几进制：&quot;);    //     scanf(&quot;%d&quot;,&amp;conver);    //     conversion(num,conver);    // &#125;while (true);    return 0;&#125; \n测试 \n括号匹配  #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define OK 1#define ERROR 0#define TRUE  1#define FALSE  0#define OVERFLOW -2typedef int ElemType;typedef int Status;#define STACK_INIT_SIZE 10#define STACKINCREMENT 5typedef struct &#123;    ElemType *base;    int top;    int size;    int increment;  &#125; SqStack;Status InitStack(SqStack &amp;S)&#123;    S.base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));    if(!S.base) exit (OVERFLOW);    S.top = 0;    S.size = STACK_INIT_SIZE;    S.increment = STACKINCREMENT;    return OK;&#125;Status StackEmpty(SqStack S) &#123;    if (S.top==0) return   TRUE;    else return   FALSE;&#125;Status Push (SqStack &amp;S, ElemType e) &#123;  ElemType* newbase;    if(S.top&gt;=S.size)&#123;        newbase=(ElemType *) realloc(S.base,(S.size+S.increment)*sizeof(ElemType));        if (NULL==newbase) return OVERFLOW;        S.base=newbase;        S.size=S.size+S.increment;        printf(&quot;已扩容：size为：%d \\n&quot;,S.size);    &#125;    S.base[S.top]=e;        S.top++;    return OK;&#125;Status Pop (SqStack &amp;S, ElemType &amp;e) &#123;    if(StackEmpty(S)) return ERROR;     e=S.base[S.top-1];    S.top--;    S.size--;    return OK;    &#125;Status Matching(char c[])&#123;    SqStack S;    ElemType e;    InitStack(S);    //puts(c);    char* string = c;    for (int i = 0; i &lt; strlen(string); i++)    &#123;        if (c[i]==&#x27;[&#x27;||c[i]==&#x27;(&#x27;)&#123;            Push(S,c[i]);        &#125; else &#123;            if(TRUE== StackEmpty(S)) &#123;                printf(&quot;不比配&quot;);                return ERROR;            &#125;             if (c[i]==&#x27;]&#x27;||c[i]==&#x27;)&#x27;)&#123;                Pop(S,e);                if (c[i]==&#x27;)&#x27; &amp;&amp; e !=&#x27;(&#x27;)&#123;                    printf(&quot;不比配&quot;);                    return ERROR;                &#125;                if (c[i]==&#x27;]&#x27;&amp;&amp;  e !=&#x27;[&#x27;) &#123;                    printf(&quot;不比配&quot;);                    return ERROR;                &#125;            &#125;        &#125;            &#125;    if (TRUE==StackEmpty(S))     &#123;        printf(&quot;匹配。。。。。。&quot;);        return OK;    &#125;        printf(&quot;不比配&quot;);    return ERROR;&#125;int main()&#123;    char c[100];    printf(&quot;请输入仅包含（ [ ] ) 的字符串\\n&quot;);    gets(c);    Matching(c);   // puts(c);    return 0;&#125; \n测试 \n","categories":["数据结构"],"tags":["栈"]},{"title":"MySQL","url":"/2021/09/15/mysql/","content":"\n增删改查\n\ninsert [into] &lt;表名&gt; [列名] values &lt;列值&gt;delete from &lt;表名&gt; [where &lt;删除条件&gt;] update &lt;表名&gt; set &lt;列名=更新值&gt; [where &lt;更新条件&gt;] select &lt;列名&gt; from &lt;表名&gt; [where &lt;查询条件表达试&gt;] [order by &lt;排序的列名&gt;[asc或desc]] SELECT[ALL|DISTINCT|DISTINCTROW|TOP] &#123;*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]&#125; FROM tableexpression[,…][IN externaldatabase] [WHERE…] [GROUP BY…] [HAVING…] [ORDER BY…]    --升序/降序   order by &lt;列名&gt; asc / order by &lt;列名&gt; desc [WITH OWNERACCESS OPTION]\n\n关于SELECT中的having和where\nwhere子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group  by子句之后才可以出现having子句。误区：不要错误的认为having和group by 必须配合使用。having和where区别：    1.having子句中可以使用字段别名，而where不能使用    2.having能够使用统计函数，但是where不能使用\n\n\n\ntruncate 截断\n\ntruncate命令，清空表truncate &lt;表名&gt;truncate 和delete的区别：    truncate重新设置自增列，计数器归零    truncate不会影响事务\n\n\ndistinct 去重\n\nSELECT DISTINCT 列名称 FROM 表名称\n\n\n\n多表查询\n\nSQL join 用于把来自两个或多个表的行结合起来。有7种join的用法，inner join，left join,right join基础在使用left/right jion时，on和where条件的区别如下：    1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左/右边表中的记录。    2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left/right join的含义（必须返回左/右边表的记录）了，条件不为真的就全部过滤掉。left join : 左连接，返回左表中所有的记录以及右表中连接字段相等的记录。right join : 右连接，返回右表中所有的记录以及左表中连接字段相等的记录。inner join : 内连接，又叫等值连接，只返回两个表中连接字段相等的行。意会\n\n\n\n一些函数\n\n查看版本号  select version()系统用户    select user()/system_user()------数值类函数ABS\t        求绝对值SQRT\t    求二次方根MOD\t        求余数CEIL 和 CEILING\t两个函数功能相同，都是返回不小于参数的最小整数，即向上取整FLOOR\t向下取整，返回值转化为一个BIGINTRAND\t生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列ROUND\t对所传参数进行四舍五入SIGN\t返回参数的符号POW 和 POWER\t两个函数的功能相同，都是所传参数的次方的结果值SIN\t    求正弦值ASIN\t求反正弦值，与函数 SIN 互为反函数COS\t    求余弦值ACOS\t求反余弦值，与函数 COS 互为反函数TAN\t    求正切值ATAN\t求反正切值，与函数 TAN 互为反函数COT\t    求余切值---字符串函数LENGTH\t计算字符串长度函数，返回字符串的字节长度char_length 获取字符串长度    1）、length()：mysql里面的length()函数是一个用来获取字符串长度的内置函数。　　2）、char_length()：在mysql内置函数里面查看字符串长度的还有一个函数是char_length()。　　3）、这两个函数的区别是：　　　　a）、length()： 单位是字节，utf8编码下,一个汉字三个字节，一个数字或字母一个字节。gbk编码下,一个汉字两个字节，一个数字或字母一个字节。　　　　b）、char_length()：单位为字符，不管汉字还是数字或者是字母都算是一个字符。CONCAT\t合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个INSERT\t替换字符串函数   insert(开始下标，替换长度，替换字符)instr   返回第一次出现字串的索引LOWER\t将字符串中的字母转换为小写UPPER\t将字符串中的字母转换为大写LEFT\t从左侧字截取符串，返回字符串左边的若干个字符RIGHT\t从右侧字截取符串，返回字符串右边的若干个字符TRIM\t删除字符串左右两侧的空格REPLACE\t字符串替换函数，返回替换后的新字符串SUBSTRING\t截取字符串，返回从指定位置开始的指定长度的字符换REVERSE\t字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串--日期函数CURDATE 和 CURRENT_DATE\t两个函数作用相同，返回当前系统的日期值CURTIME 和 CURRENT_TIME\t两个函数作用相同，返回当前系统的时间值NOW 和  SYSDATE\t两个函数作用相同，返回当前系统的日期和时间值UNIX_TIMESTAMP\t获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数FROM_UNIXTIME\t将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数MONTH\t获取指定日期中的月份MONTHNAME\t获取指定日期中的月份英文名称DAYNAME\t获取指定曰期对应的星期几的英文名称DAYOFWEEK\t获取指定日期对应的一周的索引位置值WEEK\t获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53DAYOFYEAR\t获取指定曰期是一年中的第几天，返回值范围是1~366DAYOFMONTH\t获取指定日期是一个月中是第几天，返回值范围是1~31YEAR\t获取年份，返回值范围是 1970〜2069TIME_TO_SEC\t将时间参数转换为秒数SEC_TO_TIME\t将秒数转换为时间，与TIME_TO_SEC 互为反函数DATE_ADD 和 ADDDATE\t两个函数功能相同，都是向日期添加指定的时间间隔DATE_SUB 和 SUBDATE\t两个函数功能相同，都是向日期减去指定的时间间隔ADDTIME\t时间加法运算，在原始时间上添加指定的时间SUBTIME\t时间减法运算，在原始时间上减去指定的时间DATEDIFF\t获取两个日期之间间隔，返回参数 1 减去参数 2 的值DATE_FORMAT\t格式化指定的日期，根据参数返回指定格式的值WEEKDAY\t获取指定日期在一周内的对应的工作日索引---聚合函数MAX\t查询指定列的最大值MIN\t查询指定列的最小值COUNT\t统计查询结果的行数    1)count(*)、count(1)、count(列名)区别         count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。         count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL         count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL    2)执行效率        列名为主键，count(列名)会比count(1)快        列名不为主键，count(1)会比count(列名)快        如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）        如果有主键，则 select count（主键）的执行效率是最优的        如果表只有一个字段，则 select count（*）最优。        《注：这三种区别好像并不大，暂不讨论》        SUM\t求和，返回指定列的总和AVG\t求平均值，返回指定列数据的平均值\n\n\n\n==事务== （重要）\n1. MySQL是默认开启事务的2.直接用 SET 来改变 MySQL 的自动提交模式:    SET AUTOCOMMIT=0 禁止自动提交    SET AUTOCOMMIT=1 开启自动提交\n事务：\n* 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。\n* MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。\n\n事务管理：ACID\n* 原子性 Atomicity：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n* 一致性 Consistency：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。（既，事务前后数据的完整性要保持一致）\n\n* 隔离性 Isolation：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n\n* 持久性 Durability：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n事务的隔离级别问题：\n脏读：一个事务读取到另外一个未提交事务的数据   不可重复读：在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误，只是某些场合不对）  虚读(幻读)：是指在一个事务内读取到了别的事务插入的数据，导致前后读取数量总量不一致。\n\n\n索引 （重要）\n索引： MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。\n索引分类\n主键索引:唯一索引：常规索引：全文索引：\n\n三大范式\n\n1NF:要求数据库表的每一列都是不可分割的原子数据项。2NF:在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）3NF:在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）\n\n\n\n\n","categories":["MySQL"],"tags":["MySQL"]}]