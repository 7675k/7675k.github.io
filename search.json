[{"title":"TITLE","url":"/2021/09/15/demo/","content":"hello worldtest1test2hello "},{"title":"单链表基本操作实现","url":"/2021/09/19/SingleLinkedList/","content":"链表链表的基本概念链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的，链表每个节点有两部分分组成，一个是数据域（也就是该元素的数据信息）用element表示，一个是指针域（与就是对于下一个节点的引用）用next表示；\n链表的设计与实现\n接口设计/** * 清除所有元素 */void clear();/** * 元素的数量 * @return */int size();/** * 是否为空 * @return */boolean isEmpty();/** * 是否包含某个元素 * @param element * @return */boolean contains(E element);/** * 添加元素到尾部 * @param element */void add(E element);/** * 获取index位置的元素 * @param index * @return */E get(int index);/** * 设置index位置的元素 * @param index * @param element * @return 原来的元素ֵ */E set(int index, E element);/** * 在index位置插入一个元素 * @param index * @param element */void add(int index, E element);/** * 删除index位置的元素 * @param index * @return */E remove(int index);/** * 查看元素的索引 * @param element * @return */int indexOf(E element);\n\n接口的实现package priv.kun.LinkedList;/** * @author likun * @Package priv.kun.LinkedList * @Description: * @date */public class SingleLinkedList&lt;E&gt; &#123;    private int size; //元素的数量    private Node&lt;E&gt; first; //头节点    private static class Node&lt;E&gt;&#123;        E element;        Node&lt;E&gt; next;        public Node(E element,Node&lt;E&gt; next)&#123;            this.element=element;            this.next=next;        &#125;    &#125;    /**     * 清空     * size设置为0 ，头节点为null     */    public void clear() &#123;        size=0;        first=null;    &#125;    /**     * 元素的数量     * @return     */    public int size() &#123;        return size;    &#125;    /**     * 是否为空     * @return     */    public boolean isEmpty() &#123;        return size==0;    &#125;    /**     * 返回某个元素的位置     * @param element     * @return     */    public int indexOf(E element) &#123;        if (element==null)&#123;            Node&lt;E&gt; node=first;            for (int i=0;i&lt;size;i++)&#123;                if (node.element==null) return i;                node=node.next;            &#125;        &#125;else &#123;            Node&lt;E&gt; node=first;            for (int i=0;i&lt;size;i++)&#123;                if (element.equals(node.element)) return i;                node=node.next;            &#125;        &#125;        return -1;    &#125;    /**     * 是否包含某个元素     * @param element     * @return     */    public boolean contains(E element) &#123;        return indexOf(element) != -1;    &#125;    /**     * 在尾部添加元素     * @param element     */    public void add(E element) &#123;        add(size,element);    &#125;    /**     * 在index位置添加元素     * @param index     * @param element     */    public void add(int index, E element) &#123;        if (index == 0) &#123;            first = new Node&lt;&gt;(element, null);        &#125; else &#123;            Node&lt;E&gt; prev = node(index - 1);            prev.next = new Node&lt;&gt;(element, prev.next);        &#125;        size++;    &#125;    /**     * 返回 index位置的元素     * @param index     * @return     */    public E get(int index) &#123;        return node(index).element;    &#125;    /**     * 返回某个位置节点     * @param index     * @return     */    public Node&lt;E&gt; node(int index)&#123;        Node&lt;E&gt; node=first;        for (int i=0;i&lt;index;i++)&#123;            node=node.next;        &#125;        return node;    &#125;    /**     * 设置index位置的元素     * @param index     * @param element     * @return     */    public E set(int index, E element) &#123;        Node&lt;E&gt; node = node(index); //找到index 位置的节点        E oldElement = node.element;        node.element=element;        return oldElement;    &#125;    /**     * 删除 index位置的元素     * @param index     * @return     */    public E remove(int index) &#123;        Node&lt;E&gt; node = node(index);//删除的节点        if (index==0)&#123; //删除的是第一个节点            first=node.next;        &#125; else &#123;            Node&lt;E&gt; prev = node(index - 1); //删除的前一个节点            Node&lt;E&gt; next = node.next; //删除节点的后一个节点            prev.next=next; //        &#125;        size--;        return node.element;    &#125;    @Override    public String toString() &#123;        StringBuilder stringBuilder = new StringBuilder();        stringBuilder.append(&quot;size:&quot;).append(size).append(&quot; ,[&quot;);        Node&lt;E&gt; node=first;        for (int i=0;i&lt;size;i++)&#123;            if (i!=0)&#123;                stringBuilder.append(&quot;,&quot;);            &#125;            stringBuilder.append(node.element);            node=node.next;        &#125;        stringBuilder.append(&quot;]&quot;);        return stringBuilder.toString();    &#125;&#125;\n\n测试@Test   public void test1()&#123;       SingleLinkedList&lt;Integer&gt; list = new SingleLinkedList&lt;&gt;();       list.add(1);       list.add(2);       list.set(0,111);       System.out.println(list.get(0));       System.out.println(list);   &#125;\n\n这里的实现并没有做一些非法参数传入入的处理，例如node(-5),这一看就不合理，默认先认为传入的数据都是合理的，并且有一些错误java就可以抛出异常。\n（实现的可能有错误，或者不合理的地方，等发现在修改）\nC语言实现链表实现思路和上面一样，\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /*     定义结构 */typedef struct Node&#123;    int  element;   //c语言中好像没有泛型，默认就是int类型的元素      struct Node *next;&#125;Node;Node* init();Node* add(Node* frist,int element); //添加节点Node* addForIndex(Node* first,int index,int element); //添加节点在index位置Node* findNode(Node* frist,int index);  //查找index位置的节点void display(Node *p);  //打印Node* del(Node *first,int index);  //删除index位置的节点Node* clear(Node* first); //清空//Node *first; //定义单链表的头指针int size=0; //元素数量Node* init()&#123;    Node * first;    first=NULL;    return first;&#125;/* 添加节点 */Node* add(Node* first,int element)&#123;    return addForIndex(first,size,element);&#125;/* 在index位置添加节点 */Node* addForIndex(Node* first,int index,int element)&#123;    if(size==0)&#123;        Node *c=(Node*)malloc(sizeof(Node));  //分配一个节点，并让指针p指向这个节点        first=c;      /*   first-&gt;element=element;        first-&gt;next=NULL; */        first-&gt; element=element;        first-&gt; next=NULL;     &#125;else&#123;        Node *c=(Node*)malloc(sizeof(Node));  //添加的节点        Node *prev=findNode(first,index-1);  //添加节点的前一个节点        c-&gt; element=element;        c-&gt; next=prev-&gt;next;        prev-&gt;next=c;    &#125;    size++;    return first;&#125;Node* findNode(Node* first,int index)&#123;    Node *temp=first;    for(int i=0;i&lt;index;i++)&#123;        temp=temp-&gt;next;    &#125; /*     Node *c=(Node*)malloc(sizeof(Node)); */    return temp;&#125;void display(Node *p)&#123;    Node* temp=p;    while (temp!=NULL) &#123;        printf(&quot;%d &quot;,temp-&gt;element);        temp=temp-&gt;next;    &#125;    printf(&quot;\\n&quot;);    printf(&quot;size=%d&quot;,size);    printf(&quot;\\n&quot;);&#125;/** * 删除节点 */Node* del(Node* first,int index)&#123;    Node *del=findNode(first,index); //删除的节点    if(index==0)&#123;        first=del-&gt;next;    &#125;else&#123;        Node *prev=findNode(first,index-1);        prev-&gt;next=prev-&gt;next-&gt;next;    &#125;    free(del);    size--;    return first;&#125;Node* clear(Node* first)&#123;    int temp=size;    for(int i=0;i&lt;temp;i++)&#123;        del(first,0);    &#125;    size=0;    return first;&#125;void main()&#123;    // add(2);    // add(3);    // add(4);    // addForIndex(3,6);    // //clear();    // add(5644);    // /* del(0);    // del(3); */    // del(0);    // del(0);    // del(0);    // clear();    // add(123);    // display(first);   /*  Node *c=findNode(2);    printf(&quot;%d&quot;,c-&gt;element); */     Node* first=init();   first=add(first,1);   first=add(first,3);   first=del(first,0);   clear(first);   first=add(first,123);    display(first);     printf(&quot;\\nthis is main&quot;);&#125;\n\n","categories":["数据结构"],"tags":["链表"]}]